import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import autoprefixer from 'autoprefixer';
import path from 'path';
import fs from 'fs';
import handlebars from 'handlebars';
import { nodePolyfills } from 'vite-plugin-node-polyfills';

const pages = {"ood":{"outputDir":"./ood","lang":"en","cacheVersion":20,"meta":[{"name":"twitter:card","content":"summary"},{"property":"og:type","content":"website"},{"name":"robots","content":"index, follow"}],"scripts":{"head":"<script>\n/**\n* Firebase Cloud Messaging pour WeWeb avec Cloudflare Worker\n* Version production optimisée avec détection d'appareil\n*\n* @author Julien Masbou\n* @version 2.0.0\n*/\n\n/**\n* Configuration Firebase et FCM\n* @readonly\n*/\nconst FCM_CONFIG = {\nfirebase: {\napiKey: \"AIzaSyA5fdlf7NQZzvOGH0N5lLtic30ewPtxuyY\",\nauthDomain: \"seller-pro-tool.firebaseapp.com\",\nprojectId: \"seller-pro-tool\",\nstorageBucket: \"seller-pro-tool.firebasestorage.app\",\nmessagingSenderId: \"523471159734\",\nappId: \"1:523471159734:web:f513f20875bbbcae994117\"\n},\nvapidKey: \"BI4xhJAYuonpbqHtK0zFlC3XLzkFBTSTLHU-Cu1zOWUOIGydBAcOcUguhqwxVRsCT1Xf_IM_f_eFVGgyYWsOPnM\",\nserviceWorkerUrl: \"/firebase-messaging-sw.js\", // Servi par Cloudflare Worker\nserviceWorkerScope: \"/fcm/\"\n};\n\n/**\n* État global de l'application FCM\n* Centralise toutes les informations de session\n* @readonly\n*/\nconst FCMState = {\ninitialized: false, // État d'initialisation\nmessaging: null, // Instance Firebase Messaging\ncurrentToken: null, // Token FCM actuel\nswRegistration: null // Registration du Service Worker\n};\n\n/**\n* Utilitaire pour créer des réponses standardisées\n* @param {boolean} success - Succès de l'opération\n* @param {string} message - Message à afficher\n* @param {object} data - Données supplémentaires\n* @returns {object} Réponse standardisée\n*/\nfunction createResponse(success, message, data = {}) {\nreturn {\nsuccess,\nmessage,\n...(success ? data : { error: message }),\n...data\n};\n}\n\n/**\n* Vérifie les prérequis de l'environnement pour FCM\n* @throws {Error} Si l'environnement n'est pas compatible\n*/\nfunction checkEnvironment() {\nif (!('serviceWorker' in navigator) || !('Notification' in window)) {\nthrow new Error('Service Workers ou Notifications non supportés');\n}\n\nif (window.location.protocol !== 'https:') {\nthrow new Error('HTTPS requis');\n}\n}\n\n/**\n* Initialise Firebase Cloud Messaging avec tous les prérequis\n* @returns {Promise<boolean>} true si l'initialisation réussit\n    * @throws {Error} Si l'initialisation échoue\n    */\n    async function initializeFCM() {\n    // Éviter la réinitialisation si déjà fait\n    if (FCMState.initialized) return true;\n\n    try {\n    // 1. Vérifier que l'environnement supporte FCM (HTTPS + Service Workers)\n    checkEnvironment();\n\n    // 2. Charger les SDKs Firebase si pas encore disponibles\n    if (!window.firebase) {\n    await loadFirebaseSDK();\n    }\n\n    // 3. Vérifier que le Service Worker FCM est accessible via Cloudflare\n    await validateServiceWorker();\n\n    // 4. Enregistrer le Service Worker dans le navigateur\n    await registerServiceWorker();\n\n    // 5. Initialiser Firebase et configurer les gestionnaires\n    await initializeFirebaseMessaging();\n\n    // Marquer comme initialisé pour éviter les doublons\n    FCMState.initialized = true;\n    return true;\n\n    } catch (error) {\n    // Propager l'erreur sans modification pour le debug\n    throw error;\n    }\n    }\n\n    /**\n    * Valide que le Service Worker FCM est accessible\n    * @throws {Error} Si le Service Worker n'est pas accessible\n    */\n    async function validateServiceWorker() {\n    const swResponse = await fetch(FCM_CONFIG.serviceWorkerUrl);\n    if (!swResponse.ok) {\n    throw new Error('Service Worker non accessible');\n    }\n    }\n\n    /**\n    * Enregistre le Service Worker FCM\n    * @throws {Error} Si l'enregistrement échoue\n    */\n    async function registerServiceWorker() {\n    FCMState.swRegistration = await navigator.serviceWorker.register(\n    FCM_CONFIG.serviceWorkerUrl,\n    { scope: FCM_CONFIG.serviceWorkerScope }\n    );\n\n    await navigator.serviceWorker.ready;\n    }\n\n    /**\n    * Initialise Firebase et configure les gestionnaires de messages\n    * @throws {Error} Si l'initialisation Firebase échoue\n    */\n    async function initializeFirebaseMessaging() {\n    if (!firebase.apps.length) {\n    firebase.initializeApp(FCM_CONFIG.firebase);\n    }\n\n    FCMState.messaging = firebase.messaging();\n\n    // Gestionnaire des messages en premier plan\n    FCMState.messaging.onMessage((payload) => {\n    if (payload.data?.showInForeground === 'true') {\n    showForegroundNotification(payload);\n    }\n    });\n    }\n\n    /**\n    * Charge dynamiquement les SDKs Firebase nécessaires\n    * @returns {Promise<object>} Instance Firebase\n * @throws {Error} Si le chargement échoue\n */\nasync function loadFirebaseSDK() {\n  if (window.firebase) return window.firebase;\n  \n  // Charger Firebase App SDK\n  await loadScript('https://www.gstatic.com/firebasejs/10.7.2/firebase-app-compat.js', 'Firebase App');\n  \n  // Charger Firebase Messaging SDK\n  await loadScript('https://www.gstatic.com/firebasejs/10.7.2/firebase-messaging-compat.js', 'Firebase Messaging');\n  \n  return window.firebase;\n}\n\n/**\n * Charge un script dynamiquement\n * @param {string} src - URL du script\n * @param {string} name - Nom du script pour les erreurs\n * @returns {Promise} Promise qui se résout quand le script est chargé\n */\nfunction loadScript(src, name) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    script.src = src;\n    script.onload = resolve;\n    script.onerror = () => reject(new Error(`Erreur chargement ${name}`));\n    document.head.appendChild(script);\n  });\n}\n\n/**\n * Demande la permission de notifications et obtient le token FCM\n * @returns {Promise<string>} Token FCM\n * @throws {Error} Si la permission est refusée ou le token non généré\n */\nasync function requestPermissionAndGetToken() {\n  if (!FCMState.initialized) {\n    await initializeFCM();\n  }\n  \n  // Vérifier et demander permission\n  await ensureNotificationPermission();\n  \n  // Obtenir token FCM\n  const token = await FCMState.messaging.getToken({\n    vapidKey: FCM_CONFIG.vapidKey,\n    serviceWorkerRegistration: FCMState.swRegistration\n  });\n  \n  if (!token) {\n    throw new Error('Token non généré');\n  }\n  \n  // Sauvegarder le token\n  saveTokenToStorage(token);\n  \n  return token;\n}\n\n/**\n * Vérifie et demande la permission de notifications si nécessaire\n * @throws {Error} Si la permission est refusée\n */\nasync function ensureNotificationPermission() {\n  if (Notification.permission === 'denied') {\n    throw new Error('Permission refusée');\n  }\n  \n  if (Notification.permission !== 'granted') {\n    const permission = await Notification.requestPermission();\n    if (permission !== 'granted') {\n      throw new Error('Permission non accordée');\n    }\n  }\n}\n\n/**\n * Sauvegarde le token FCM en localStorage avec timestamp\n * @param {string} token - Token FCM à sauvegarder\n */\nfunction saveTokenToStorage(token) {\n  FCMState.currentToken = token;\n  localStorage.setItem('fcm_token', token);\n  localStorage.setItem('fcm_token_timestamp', Date.now().toString());\n}\n\n/**\n * Désabonne l'utilisateur des notifications FCM\n * @throws {Error} Si la désabonnement échoue\n */\nasync function unsubscribe() {\n  if (FCMState.messaging) {\n    await FCMState.messaging.deleteToken();\n  }\n  \n  // Nettoyer le localStorage et l'état\n  clearTokenFromStorage();\n}\n\n/**\n * Supprime le token de localStorage et remet à zéro l'état\n */\nfunction clearTokenFromStorage() {\n  localStorage.removeItem('fcm_token');\n  localStorage.removeItem('fcm_token_timestamp');\n  FCMState.currentToken = null;\n}\n\n/**\n * Détecte la marque et le modèle de l'appareil à partir du userAgent\n * @returns {string} Nom de l'appareil (ex: \"iPhone 15 Pro\", \"Samsung Galaxy S23\", \"Mac\")\n */\nfunction getDeviceBrandModel() {\n  const ua = navigator.userAgent;\n  \n  // iPhone - Détection du modèle via dimensions d'écran\n  // Note: iOS Safari ne révèle pas le modèle exact, on utilise les dimensions d'écran\n  if (/iPhone/.test(ua)) {\n    const width = screen.width;\n    const height = screen.height;\n    \n    // Résolutions connues des iPhone (en CSS pixels)\n    // Source: Apple Developer Documentation\n    if (width === 393 && height === 852) return \"iPhone 15 Pro\";\n    if (width === 414 && height === 896) return \"iPhone 11\";\n    if (width === 375 && height === 812) return \"iPhone X\";\n    if (width === 414 && height === 736) return \"iPhone 8 Plus\";\n    if (width === 375 && height === 667) return \"iPhone 8\";\n    \n    // Fallback pour modèles non détectés\n    return \"iPhone\";\n  }\n  \n  // iPad - Détection par largeur d'écran\n  if (/iPad/.test(ua)) {\n    const width = screen.width;\n    \n    // Classification basée sur la largeur standard des iPad\n    if (width >= 1024) return \"iPad Pro\";      // 12.9\" ou 11\"\n    if (width >= 820) return \"iPad Air\";       // 10.9\"\n    if (width >= 768) return \"iPad\";           // 9.7\" ou 10.2\"\n    \n    return \"iPad\";\n  }\n  \n  // Android - Extraction marque/modèle depuis userAgent\n  if (/Android/.test(ua)) {\n    // Pattern regex pour extraire le nom de l'appareil Android\n    // Format typique: \"Android X.X; Model) AppleWebKit...\"\n    const deviceMatch = ua.match(/;\\s*([^;)]+)\\s*\\)/);\n    if (deviceMatch) {\n      let device = deviceMatch[1]\n        .replace(/Build\\/.*$/, '')  // Enlever les infos de build\n        .trim();\n      \n      // Limiter la longueur pour éviter les noms trop longs\n      if (device.length > 25) {\n        device = device.substring(0, 25) + \"...\";\n      }\n      \n      return device;\n    }\n    \n    // Fallback si extraction échoue\n    return \"Android\";\n  }\n  \n  // Desktop - Détection OS simple\n  if (/Mac/.test(ua)) return \"Mac\";\n  if (/Windows/.test(ua)) return \"Windows PC\";\n  if (/Linux/.test(ua)) return \"Linux PC\";\n  \n  // Fallback générique\n  return \"Navigateur Web\";\n}\n\n/**\n * Affiche une notification en premier plan (foreground)\n * @param {object} payload - Payload de la notification FCM\n */\nfunction showForegroundNotification(payload) {\n  if (Notification.permission !== 'granted') return;\n  \n  const notification = new Notification(\n    payload.notification?.title || 'Notification',\n    {\n      body: payload.notification?.body || '',\n      icon: payload.notification?.icon || '/favicon.ico',\n      tag: 'fcm-foreground',\n      data: payload.data\n    }\n  );\n  \n  notification.onclick = () => {\n    if (payload.data?.url) {\n      window.location.href = payload.data.url;\n    }\n    notification.close();\n  };\n}\n\n/**\n * API publique FCMCloudflare pour WeWeb\n * Interface simplifiée pour la gestion des notifications push\n * \n * UTILISATION:\n * const result = await FCMCloudflare.subscribe();\n * if (result.success) {\n *   console.log('Token:', result.token);\n *   console.log('Appareil:', result.name);\n * }\n * \n * @namespace FCMCloudflare\n * @global\n */\nwindow.FCMCloudflare = {\n  // Actions principales\n  init: initializeFCM,\n  \n  /**\n   * S'abonne aux notifications push\n   * @returns {Promise<object>} Résultat avec token, nom appareil et statut\n   */\n  subscribe: async () => {\n    try {\n      const token = await requestPermissionAndGetToken();\n      return createResponse(true, 'Notifications activées', {\n        token,\n        name: getDeviceBrandModel()\n      });\n    } catch (error) {\n      return createResponse(false, `Erreur: ${error.message}`);\n    }\n  },\n  \n  /**\n   * Se désabonne des notifications push\n   * @returns {Promise<object>} Résultat de la désabonnement\n   */\n  unsubscribe: async () => {\n    try {\n      await unsubscribe();\n      return createResponse(true, 'Notifications désactivées');\n    } catch (error) {\n      return createResponse(false, error.message);\n    }\n  },\n  \n  // Getters utilitaires\n  getToken: () => FCMState.currentToken,\n  isInitialized: () => FCMState.initialized,\n  \n  /**\n   * Retourne l'état complet de FCM\n   * @returns {object} État détaillé de l'initialisation et des permissions\n   */\n  getStatus: () => ({\n    initialized: FCMState.initialized,\n    hasToken: !!FCMState.currentToken,\n    permission: Notification.permission,\n    serviceWorkerActive: !!FCMState.swRegistration?.active\n  })\n};\n</script>\n","body":"\n"},"baseTag":{"href":"/","target":"_self"},"alternateLinks":[{"rel":"alternate","hreflang":"x-default","href":"https://www.nanofacto.com/ood/"},{"rel":"alternate","hreflang":"en","href":"https://www.nanofacto.com/ood/"}]},"index":{"outputDir":"./","lang":"en","cacheVersion":20,"meta":[{"name":"twitter:card","content":"summary"},{"property":"og:type","content":"website"},{"name":"robots","content":"index, follow"}],"scripts":{"head":"<script>\n/**\n* Firebase Cloud Messaging pour WeWeb avec Cloudflare Worker\n* Version production optimisée avec détection d'appareil\n*\n* @author Julien Masbou\n* @version 2.0.0\n*/\n\n/**\n* Configuration Firebase et FCM\n* @readonly\n*/\nconst FCM_CONFIG = {\nfirebase: {\napiKey: \"AIzaSyA5fdlf7NQZzvOGH0N5lLtic30ewPtxuyY\",\nauthDomain: \"seller-pro-tool.firebaseapp.com\",\nprojectId: \"seller-pro-tool\",\nstorageBucket: \"seller-pro-tool.firebasestorage.app\",\nmessagingSenderId: \"523471159734\",\nappId: \"1:523471159734:web:f513f20875bbbcae994117\"\n},\nvapidKey: \"BI4xhJAYuonpbqHtK0zFlC3XLzkFBTSTLHU-Cu1zOWUOIGydBAcOcUguhqwxVRsCT1Xf_IM_f_eFVGgyYWsOPnM\",\nserviceWorkerUrl: \"/firebase-messaging-sw.js\", // Servi par Cloudflare Worker\nserviceWorkerScope: \"/fcm/\"\n};\n\n/**\n* État global de l'application FCM\n* Centralise toutes les informations de session\n* @readonly\n*/\nconst FCMState = {\ninitialized: false, // État d'initialisation\nmessaging: null, // Instance Firebase Messaging\ncurrentToken: null, // Token FCM actuel\nswRegistration: null // Registration du Service Worker\n};\n\n/**\n* Utilitaire pour créer des réponses standardisées\n* @param {boolean} success - Succès de l'opération\n* @param {string} message - Message à afficher\n* @param {object} data - Données supplémentaires\n* @returns {object} Réponse standardisée\n*/\nfunction createResponse(success, message, data = {}) {\nreturn {\nsuccess,\nmessage,\n...(success ? data : { error: message }),\n...data\n};\n}\n\n/**\n* Vérifie les prérequis de l'environnement pour FCM\n* @throws {Error} Si l'environnement n'est pas compatible\n*/\nfunction checkEnvironment() {\nif (!('serviceWorker' in navigator) || !('Notification' in window)) {\nthrow new Error('Service Workers ou Notifications non supportés');\n}\n\nif (window.location.protocol !== 'https:') {\nthrow new Error('HTTPS requis');\n}\n}\n\n/**\n* Initialise Firebase Cloud Messaging avec tous les prérequis\n* @returns {Promise<boolean>} true si l'initialisation réussit\n    * @throws {Error} Si l'initialisation échoue\n    */\n    async function initializeFCM() {\n    // Éviter la réinitialisation si déjà fait\n    if (FCMState.initialized) return true;\n\n    try {\n    // 1. Vérifier que l'environnement supporte FCM (HTTPS + Service Workers)\n    checkEnvironment();\n\n    // 2. Charger les SDKs Firebase si pas encore disponibles\n    if (!window.firebase) {\n    await loadFirebaseSDK();\n    }\n\n    // 3. Vérifier que le Service Worker FCM est accessible via Cloudflare\n    await validateServiceWorker();\n\n    // 4. Enregistrer le Service Worker dans le navigateur\n    await registerServiceWorker();\n\n    // 5. Initialiser Firebase et configurer les gestionnaires\n    await initializeFirebaseMessaging();\n\n    // Marquer comme initialisé pour éviter les doublons\n    FCMState.initialized = true;\n    return true;\n\n    } catch (error) {\n    // Propager l'erreur sans modification pour le debug\n    throw error;\n    }\n    }\n\n    /**\n    * Valide que le Service Worker FCM est accessible\n    * @throws {Error} Si le Service Worker n'est pas accessible\n    */\n    async function validateServiceWorker() {\n    const swResponse = await fetch(FCM_CONFIG.serviceWorkerUrl);\n    if (!swResponse.ok) {\n    throw new Error('Service Worker non accessible');\n    }\n    }\n\n    /**\n    * Enregistre le Service Worker FCM\n    * @throws {Error} Si l'enregistrement échoue\n    */\n    async function registerServiceWorker() {\n    FCMState.swRegistration = await navigator.serviceWorker.register(\n    FCM_CONFIG.serviceWorkerUrl,\n    { scope: FCM_CONFIG.serviceWorkerScope }\n    );\n\n    await navigator.serviceWorker.ready;\n    }\n\n    /**\n    * Initialise Firebase et configure les gestionnaires de messages\n    * @throws {Error} Si l'initialisation Firebase échoue\n    */\n    async function initializeFirebaseMessaging() {\n    if (!firebase.apps.length) {\n    firebase.initializeApp(FCM_CONFIG.firebase);\n    }\n\n    FCMState.messaging = firebase.messaging();\n\n    // Gestionnaire des messages en premier plan\n    FCMState.messaging.onMessage((payload) => {\n    if (payload.data?.showInForeground === 'true') {\n    showForegroundNotification(payload);\n    }\n    });\n    }\n\n    /**\n    * Charge dynamiquement les SDKs Firebase nécessaires\n    * @returns {Promise<object>} Instance Firebase\n * @throws {Error} Si le chargement échoue\n */\nasync function loadFirebaseSDK() {\n  if (window.firebase) return window.firebase;\n  \n  // Charger Firebase App SDK\n  await loadScript('https://www.gstatic.com/firebasejs/10.7.2/firebase-app-compat.js', 'Firebase App');\n  \n  // Charger Firebase Messaging SDK\n  await loadScript('https://www.gstatic.com/firebasejs/10.7.2/firebase-messaging-compat.js', 'Firebase Messaging');\n  \n  return window.firebase;\n}\n\n/**\n * Charge un script dynamiquement\n * @param {string} src - URL du script\n * @param {string} name - Nom du script pour les erreurs\n * @returns {Promise} Promise qui se résout quand le script est chargé\n */\nfunction loadScript(src, name) {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    script.src = src;\n    script.onload = resolve;\n    script.onerror = () => reject(new Error(`Erreur chargement ${name}`));\n    document.head.appendChild(script);\n  });\n}\n\n/**\n * Demande la permission de notifications et obtient le token FCM\n * @returns {Promise<string>} Token FCM\n * @throws {Error} Si la permission est refusée ou le token non généré\n */\nasync function requestPermissionAndGetToken() {\n  if (!FCMState.initialized) {\n    await initializeFCM();\n  }\n  \n  // Vérifier et demander permission\n  await ensureNotificationPermission();\n  \n  // Obtenir token FCM\n  const token = await FCMState.messaging.getToken({\n    vapidKey: FCM_CONFIG.vapidKey,\n    serviceWorkerRegistration: FCMState.swRegistration\n  });\n  \n  if (!token) {\n    throw new Error('Token non généré');\n  }\n  \n  // Sauvegarder le token\n  saveTokenToStorage(token);\n  \n  return token;\n}\n\n/**\n * Vérifie et demande la permission de notifications si nécessaire\n * @throws {Error} Si la permission est refusée\n */\nasync function ensureNotificationPermission() {\n  if (Notification.permission === 'denied') {\n    throw new Error('Permission refusée');\n  }\n  \n  if (Notification.permission !== 'granted') {\n    const permission = await Notification.requestPermission();\n    if (permission !== 'granted') {\n      throw new Error('Permission non accordée');\n    }\n  }\n}\n\n/**\n * Sauvegarde le token FCM en localStorage avec timestamp\n * @param {string} token - Token FCM à sauvegarder\n */\nfunction saveTokenToStorage(token) {\n  FCMState.currentToken = token;\n  localStorage.setItem('fcm_token', token);\n  localStorage.setItem('fcm_token_timestamp', Date.now().toString());\n}\n\n/**\n * Désabonne l'utilisateur des notifications FCM\n * @throws {Error} Si la désabonnement échoue\n */\nasync function unsubscribe() {\n  if (FCMState.messaging) {\n    await FCMState.messaging.deleteToken();\n  }\n  \n  // Nettoyer le localStorage et l'état\n  clearTokenFromStorage();\n}\n\n/**\n * Supprime le token de localStorage et remet à zéro l'état\n */\nfunction clearTokenFromStorage() {\n  localStorage.removeItem('fcm_token');\n  localStorage.removeItem('fcm_token_timestamp');\n  FCMState.currentToken = null;\n}\n\n/**\n * Détecte la marque et le modèle de l'appareil à partir du userAgent\n * @returns {string} Nom de l'appareil (ex: \"iPhone 15 Pro\", \"Samsung Galaxy S23\", \"Mac\")\n */\nfunction getDeviceBrandModel() {\n  const ua = navigator.userAgent;\n  \n  // iPhone - Détection du modèle via dimensions d'écran\n  // Note: iOS Safari ne révèle pas le modèle exact, on utilise les dimensions d'écran\n  if (/iPhone/.test(ua)) {\n    const width = screen.width;\n    const height = screen.height;\n    \n    // Résolutions connues des iPhone (en CSS pixels)\n    // Source: Apple Developer Documentation\n    if (width === 393 && height === 852) return \"iPhone 15 Pro\";\n    if (width === 414 && height === 896) return \"iPhone 11\";\n    if (width === 375 && height === 812) return \"iPhone X\";\n    if (width === 414 && height === 736) return \"iPhone 8 Plus\";\n    if (width === 375 && height === 667) return \"iPhone 8\";\n    \n    // Fallback pour modèles non détectés\n    return \"iPhone\";\n  }\n  \n  // iPad - Détection par largeur d'écran\n  if (/iPad/.test(ua)) {\n    const width = screen.width;\n    \n    // Classification basée sur la largeur standard des iPad\n    if (width >= 1024) return \"iPad Pro\";      // 12.9\" ou 11\"\n    if (width >= 820) return \"iPad Air\";       // 10.9\"\n    if (width >= 768) return \"iPad\";           // 9.7\" ou 10.2\"\n    \n    return \"iPad\";\n  }\n  \n  // Android - Extraction marque/modèle depuis userAgent\n  if (/Android/.test(ua)) {\n    // Pattern regex pour extraire le nom de l'appareil Android\n    // Format typique: \"Android X.X; Model) AppleWebKit...\"\n    const deviceMatch = ua.match(/;\\s*([^;)]+)\\s*\\)/);\n    if (deviceMatch) {\n      let device = deviceMatch[1]\n        .replace(/Build\\/.*$/, '')  // Enlever les infos de build\n        .trim();\n      \n      // Limiter la longueur pour éviter les noms trop longs\n      if (device.length > 25) {\n        device = device.substring(0, 25) + \"...\";\n      }\n      \n      return device;\n    }\n    \n    // Fallback si extraction échoue\n    return \"Android\";\n  }\n  \n  // Desktop - Détection OS simple\n  if (/Mac/.test(ua)) return \"Mac\";\n  if (/Windows/.test(ua)) return \"Windows PC\";\n  if (/Linux/.test(ua)) return \"Linux PC\";\n  \n  // Fallback générique\n  return \"Navigateur Web\";\n}\n\n/**\n * Affiche une notification en premier plan (foreground)\n * @param {object} payload - Payload de la notification FCM\n */\nfunction showForegroundNotification(payload) {\n  if (Notification.permission !== 'granted') return;\n  \n  const notification = new Notification(\n    payload.notification?.title || 'Notification',\n    {\n      body: payload.notification?.body || '',\n      icon: payload.notification?.icon || '/favicon.ico',\n      tag: 'fcm-foreground',\n      data: payload.data\n    }\n  );\n  \n  notification.onclick = () => {\n    if (payload.data?.url) {\n      window.location.href = payload.data.url;\n    }\n    notification.close();\n  };\n}\n\n/**\n * API publique FCMCloudflare pour WeWeb\n * Interface simplifiée pour la gestion des notifications push\n * \n * UTILISATION:\n * const result = await FCMCloudflare.subscribe();\n * if (result.success) {\n *   console.log('Token:', result.token);\n *   console.log('Appareil:', result.name);\n * }\n * \n * @namespace FCMCloudflare\n * @global\n */\nwindow.FCMCloudflare = {\n  // Actions principales\n  init: initializeFCM,\n  \n  /**\n   * S'abonne aux notifications push\n   * @returns {Promise<object>} Résultat avec token, nom appareil et statut\n   */\n  subscribe: async () => {\n    try {\n      const token = await requestPermissionAndGetToken();\n      return createResponse(true, 'Notifications activées', {\n        token,\n        name: getDeviceBrandModel()\n      });\n    } catch (error) {\n      return createResponse(false, `Erreur: ${error.message}`);\n    }\n  },\n  \n  /**\n   * Se désabonne des notifications push\n   * @returns {Promise<object>} Résultat de la désabonnement\n   */\n  unsubscribe: async () => {\n    try {\n      await unsubscribe();\n      return createResponse(true, 'Notifications désactivées');\n    } catch (error) {\n      return createResponse(false, error.message);\n    }\n  },\n  \n  // Getters utilitaires\n  getToken: () => FCMState.currentToken,\n  isInitialized: () => FCMState.initialized,\n  \n  /**\n   * Retourne l'état complet de FCM\n   * @returns {object} État détaillé de l'initialisation et des permissions\n   */\n  getStatus: () => ({\n    initialized: FCMState.initialized,\n    hasToken: !!FCMState.currentToken,\n    permission: Notification.permission,\n    serviceWorkerActive: !!FCMState.swRegistration?.active\n  })\n};\n</script>\n","body":"\n"},"baseTag":{"href":"/","target":"_self"},"alternateLinks":[{"rel":"alternate","hreflang":"x-default","href":"https://www.nanofacto.com/"},{"rel":"alternate","hreflang":"en","href":"https://www.nanofacto.com/"}]}};

// Read the main HTML template
const template = fs.readFileSync(path.resolve(__dirname, 'template.html'), 'utf-8');
const compiledTemplate = handlebars.compile(template);

// Generate an HTML file for each page with its metadata
Object.values(pages).forEach(pageConfig => {
    // Compile the template with page metadata
    const html = compiledTemplate({
        title: pageConfig.title,
        lang: pageConfig.lang,
        meta: pageConfig.meta,
        scripts: {
            head: pageConfig.scripts.head,
            body: pageConfig.scripts.body,
        },
        alternateLinks: pageConfig.alternateLinks,
        cacheVersion: pageConfig.cacheVersion,
        baseTag: pageConfig.baseTag,
    });

    // Save output html for each page
    if (!fs.existsSync(pageConfig.outputDir)) {
        fs.mkdirSync(pageConfig.outputDir, { recursive: true });
    }
    fs.writeFileSync(`${pageConfig.outputDir}/index.html`, html);
});

const rollupOptionsInput = {};
for (const pageName in pages) {
    rollupOptionsInput[pageName] = path.resolve(__dirname, pages[pageName].outputDir, 'index.html');
}

export default defineConfig(() => {
    return {
        plugins: [nodePolyfills({ include: ['events', 'stream', 'string_decoder'] }), vue()],
        base: "/",
        resolve: {
            alias: {
                '@': path.resolve(__dirname, './src'),
            },
        },
        css: {
            preprocessorOptions: {
                scss: {
                    api: 'modern-compiler',
                },
            },
            postcss: {
                plugins: [autoprefixer],
            },
        },
        build: {
            chunkSizeWarningLimit: 10000,
            rollupOptions: {
                input: rollupOptionsInput,
                onwarn: (entry, next) => {
                    if (entry.loc?.file && /js$/.test(entry.loc.file) && /Use of eval in/.test(entry.message)) return;
                    return next(entry);
                },
                maxParallelFileOps: 900,
            },
        },
        logLevel: 'warn',
    };
});
